/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
}(this, (function() {
    "use strict";
    const t = "transitionend"
      , e = t => {
        let e = t.getAttribute("data-bs-target");
        if (!e || "#" === e) {
            let i = t.getAttribute("href");
            if (!i || !i.includes("#") && !i.startsWith("."))
                return null;
            i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`),
            e = i && "#" !== i ? i.trim() : null
        }
        return e
    }
      , i = t => {
        const i = e(t);
        return i && document.querySelector(i) ? i : null
    }
      , n = t => {
        const i = e(t);
        return i ? document.querySelector(i) : null
    }
      , s = e => {
        e.dispatchEvent(new Event(t))
    }
      , o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]),
    void 0 !== t.nodeType)
      , r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null
      , a = (t, e, i) => {
        Object.keys(i).forEach((n => {
            const s = i[n]
              , r = e[n]
              , a = r && o(r) ? "element" : null == (l = r) ? `${l}` : {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase();
            var l;
            if (!new RegExp(s).test(a))
                throw new TypeError(`${t.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`)
        }
        ))
    }
      , l = t => !(!o(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility")
      , c = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled"))
      , h = t => {
        if (!document.documentElement.attachShadow)
            return null;
        if ("function" == typeof t.getRootNode) {
            const e = t.getRootNode();
            return e instanceof ShadowRoot ? e : null
        }
        return t instanceof ShadowRoot ? t : t.parentNode ? h(t.parentNode) : null
    }
      , d = () => {}
      , u = t => {
        t.offsetHeight
    }
      , f = () => {
        const {jQuery: t} = window;
        return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null
    }
      , p = []
      , m = () => "rtl" === document.documentElement.dir
      , g = t => {
        var e;
        e = () => {
            const e = f();
            if (e) {
                const i = t.NAME
                  , n = e.fn[i];
                e.fn[i] = t.jQueryInterface,
                e.fn[i].Constructor = t,
                e.fn[i].noConflict = () => (e.fn[i] = n,
                t.jQueryInterface)
            }
        }
        ,
        "loading" === document.readyState ? (p.length || document.addEventListener("DOMContentLoaded", ( () => {
            p.forEach((t => t()))
        }
        )),
        p.push(e)) : e()
    }
      , _ = t => {
        "function" == typeof t && t()
    }
      , b = (e, i, n=!0) => {
        if (!n)
            return void _(e);
        const o = (t => {
            if (!t)
                return 0;
            let {transitionDuration: e, transitionDelay: i} = window.getComputedStyle(t);
            const n = Number.parseFloat(e)
              , s = Number.parseFloat(i);
            return n || s ? (e = e.split(",")[0],
            i = i.split(",")[0],
            1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
        }
        )(i) + 5;
        let r = !1;
        const a = ({target: n}) => {
            n === i && (r = !0,
            i.removeEventListener(t, a),
            _(e))
        }
        ;
        i.addEventListener(t, a),
        setTimeout(( () => {
            r || s(i)
        }
        ), o)
    }
      , v = (t, e, i, n) => {
        let s = t.indexOf(e);
        if (-1 === s)
            return t[!i && n ? t.length - 1 : 0];
        const o = t.length;
        return s += i ? 1 : -1,
        n && (s = (s + o) % o),
        t[Math.max(0, Math.min(s, o - 1))]
    }
      , y = /[^.]*(?=\..*)\.|.*/
      , w = /\..*/
      , E = /::\d+$/
      , A = {};
    let T = 1;
    const O = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }
      , C = /^(mouseenter|mouseleave)/i
      , k = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
    function L(t, e) {
        return e && `${e}::${T++}` || t.uidEvent || T++
    }
    function x(t) {
        const e = L(t);
        return t.uidEvent = e,
        A[e] = A[e] || {},
        A[e]
    }
    function D(t, e, i=null) {
        const n = Object.keys(t);
        for (let s = 0, o = n.length; s < o; s++) {
            const o = t[n[s]];
            if (o.originalHandler === e && o.delegationSelector === i)
                return o
        }
        return null
    }
    function S(t, e, i) {
        const n = "string" == typeof e
          , s = n ? i : e;
        let o = P(t);
        return k.has(o) || (o = t),
        [n, s, o]
    }
